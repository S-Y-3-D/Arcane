# -*- coding: utf-8 -*-
"""bg_change (1).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10kQ4G2yFIpruif3lTPJjQnQq-Cliu7yJ
"""


from typing import List
from fastapi import FastAPI, File, UploadFile
from fastapi.responses import HTMLResponse, StreamingResponse
import os
from pyngrok import ngrok
import nest_asyncio
import uvicorn
from huggingface_hub import hf_hub_download
os.system("pip -qq install facenet_pytorch")
from facenet_pytorch import MTCNN
from torchvision import transforms
import torch, PIL
from tqdm.notebook import tqdm
import torch
import base64
import io

modelarcanev4 = hf_hub_download(repo_id="akhaliq/ArcaneGANv0.4", filename="ArcaneGANv0.4.jit")
mtcnn = MTCNN(image_size=256, margin=80)

def detect(img):
  # Detect faces
  batch_boxes, batch_probs, batch_points = mtcnn.detect(img, landmarks=True)
  # Select faces
  if not mtcnn.keep_all:
      batch_boxes, batch_probs, batch_points = mtcnn.select_boxes(batch_boxes, batch_probs, batch_points, img, method=mtcnn.selection_method)
  return batch_boxes, batch_points

def makeEven(_x):
  return _x if (_x % 2 == 0) else _x+1

def scale(boxes, _img, max_res=1_500_000, target_face=256, fixed_ratio=0, max_upscale=2, VERBOSE=False):
  x, y = _img.size
  ratio = 2 #initial ratio
  #scale to desired face size
  if (boxes is not None):
    if len(boxes)>0:
      ratio = target_face/max(boxes[0][2:]-boxes[0][:2]); 
      ratio = min(ratio, max_upscale)
      if VERBOSE: print('up by', ratio)
  if fixed_ratio>0:
    if VERBOSE: print('fixed ratio')
    ratio = fixed_ratio
  x*=ratio
  y*=ratio
  #downscale to fit into max res 
  res = x*y
  if res > max_res:
    ratio = pow(res/max_res,1/2); 
    if VERBOSE: print(ratio)
    x=int(x/ratio)
    y=int(y/ratio)
  #make dimensions even, because usually NNs fail on uneven dimensions due skip connection size mismatch
  x = makeEven(int(x))
  y = makeEven(int(y))
  size = (x, y)
  return _img.resize(size)

""" 
    A useful scaler algorithm, based on face detection.
    Takes PIL.Image, returns a uniformly scaled PIL.Image
    boxes: a list of detected bboxes
    _img: PIL.Image
    max_res: maximum pixel area to fit into. Use to stay below the VRAM limits of your GPU.
    target_face: desired face size. Upscale or downscale the whole image to fit the detected face into that dimension.
    fixed_ratio: fixed scale. Ignores the face size, but doesn't ignore the max_res limit.
    max_upscale: maximum upscale ratio. Prevents from scaling images with tiny faces to a blurry mess.
"""

def scale_by_face_size(_img, max_res=1_500_000, target_face=256, fix_ratio=0, max_upscale=2, VERBOSE=False):
  boxes = None
  boxes, _ = detect(_img)
  if VERBOSE: print('boxes',boxes)
  img_resized = scale(boxes, _img, max_res, target_face, fix_ratio, max_upscale, VERBOSE)
  return img_resized

size = 256
means = [0.485, 0.456, 0.406]
stds = [0.229, 0.224, 0.225]
t_stds = torch.tensor(stds).cuda().half()[:,None,None]
t_means = torch.tensor(means).cuda().half()[:,None,None]

img_transforms = transforms.Compose([transforms.ToTensor(),transforms.Normalize(means,stds)])

def tensor2im(var):
     return var.mul(t_stds).add(t_means).mul(255.).clamp(0,255).permute(1,2,0)

def proc_pil_img(input_image, model):
    transformed_image = img_transforms(input_image)[None,...].cuda().half()
    with torch.no_grad():
        result_image = model(transformed_image)[0]
        output_image = tensor2im(result_image)
        output_image = output_image.detach().cpu().numpy().astype('uint8')
        output_image = PIL.Image.fromarray(output_image)
    return output_image

modelv4 = torch.jit.load(modelarcanev4).eval().cuda().half()

def process(im, version):
  im = scale_by_face_size(im, target_face=256, max_res=1_500_000, max_upscale=1)
  res = proc_pil_img(im, modelv4)
  return res

app = FastAPI()
from fastapi.middleware.cors import CORSMiddleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=['*'],
    allow_credentials=True,
    allow_methods=['*'],
    allow_headers=['*'],
)


@app.post("/convert_img_to_acronic")
async def acronic_pic(image: UploadFile = File(description="A file read as UploadFile")):
  process(PIL.Image.open(image), 'version 0.4').save('acronic.png')
  os.system("backgroundremover -i 'acronic.png' -o 'rm_bg.png'")
  x = PIL.Image.open('rm_bg.png').size
  PIL.Image.new(mode = "RGB", size = (x[0], x[1]), color = (97,114,239)).save('new.png')
  PIL.ImageEnhance.Brightness(PIL.Image.open('rm_bg.png')).enhance(1.5).save('bright.png')
  bg_im = PIL.Image.open('new.png').convert('RGBA')
  fg_im = PIL.Image.open('bright.png').convert('RGBA')
  bg_im.paste(fg_im, (0,0), fg_im)
  bg_im.save('output.png')
  image_file = PIL.Image.open('output.png')
  os.system("rm acronic.png rm_bg.png new.png bright.png")
  return StreamingResponse(io.BytesIO(image_file.tobytes()), media_type="image/png")


@app.get("/")
async def main():
    """Create a basic home page to upload a file

    :return: HTML for homepage
    :rtype: HTMLResponse
    """

    content = """<body>
          <h3>Upload an image to get it's depth map from the MiDaS model</h3>
          <form action="/uploadfiles/" enctype="multipart/form-data" method="post">
              <input name="files" type="file" multiple>
              <input type="submit">
          </form>
      </body>
      """
    return HTMLResponse(content=content)

auth_token = "2HxNZdYkACe8eSf7CFmVkxEPqDR_5PmwdhM5v79i3bBYDJodx" #@param {type:"string"}
# Since we can't access Colab notebooks IP directly we'll use
# ngrok to create a public URL for the server via a tunnel

# Authenticate ngrok
# https://dashboard.ngrok.com/signup
# Then go to the "Your Authtoken" tab in the sidebar and copy the API key
import os
os.system(f"ngrok authtoken {auth_token}")

public_url = ngrok.connect(8000, port='8000', bind_tls=True)

nest_asyncio.apply()
print(public_url)
uvicorn.run(app)